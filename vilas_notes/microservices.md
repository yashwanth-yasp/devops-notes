# Architecture

- Request goes to firewall and DNS,
- then goes to loadbalancer
- Loadbalacer
    - types
        - path based routing
            - `/api/writeProperExam` will hit the microservice that manages htat path
            - The loadbalancer will route this to the corresponding microservice
    - first thing that happens after it’s rerouted is Authentication
        - Authentication → are you allowed in
        - Authorization → how much you are allowed in, basically the level of permissions you have
    - It is NOT OKAY to have multiple microservices talk with a single database
    - <caps theorem>
    -Eventual consistency → Things are not immediately updated in multiple databases, but it will eventually be distributed (will there be any inconsistencies?)
        - It will eventually get updated like product page and purchase page, the new product will eventually be updated to the purchase page
        - But it will not update immediately so there can be issues in some cases
            - If you deposit money in the account and it uses eventual consistency, then it might be a problem as immediate consistency is really important
        - A good example of Eventual consistency would be something where an e-commerce app has an order placed, then it will eventually sync the data from frontend service to other services but it will say the order is placed in the frontend
    - Microservice to Microservice communication
        - Direct communication (synchronous communication)
            - directly communicate with the service
            - It’s a blocking call
                - It waits till the response comes
            - You need to have a loadbalancer to identify which instance of the microservice it needs to communicate
        - Indirect communication (asynchronous communication)
            - communication through the message broker like Rabbit/Active MQ
            - It’s  a non blocking call
                - they can continue to do their operations till there is a response
            - You don’t need a loadbalancer
            - Two types
                - queue model
                    - you don’t need a loadbalancer, as it’s only at a time
                - publish-subscribe model
                    - you don’t need a loadbalancer as the broker will manage the loadbalancing
        - API gateway
            - acts as a gateway to other services
            - Needs an authentication and authorization
            - REST api
            - json file format
    - Event sink
        - Event pahtway
        - instance 1: microservice1 → instance 10: microservice2 → instance 25: microservice3
    - Loggers``
        - Has all data logged
        - Externalise the logs
            - All the services are logged into an external logger
            - It’s really difficult to find the errors through the logs of each instance of each microservices
            - An external logger helps with this
            - Examples
                - ELK
                - Datadog(AI based)
    - Scheduling
        - There are processes that needs to be done before the client requests it
        - Scheduler can be used to set up processes like that and  it will execute these processes before the client requests it
        - The example can be something simple like updating out of stock products before the customer searches for the product


- Cascading retries 
	- If you have multiple microservices talking to each other and retry is present and the microservice at the lowest level is throwing an error, then we would have retries for each microservices at till point, which is way too many retries 
- Solution 
	- Circuit breaker 
		- It has a certiain number of requests till which it doesn't bother to interfere, say 3 but after that it will check how many requests out of that succeded, depending on the percentage of failure, it would break the circuit and send the connection to itself in the hope that by the time the request to itself is processed, the other microservice might recover 
